## 数据结构与算法

[TOC]

### :watermelon:数据结构

#### B，B+，B*树的原理

**1 B树—多叉平衡查找树**

对于一棵M阶的B树：

* 根节点的儿子数为 **[2, M]**

* 除根节点的非叶子节点：儿子数为 **[M/2, M]**

* 除根节点的非叶子节点：**关键字个数=指向儿子的指针数-1**，即 [M/2-1, M-1]

* 位于关键字 K[i-1], K[i] 之间的指针 P[i]，指向关键字属于 **(**K[i-1], K[i]) 的子树

* 关键字分部在整棵树中，搜索性能等于在关键字全集内做二分查找

  <img src="https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/524341-20160414100804004-506796201.jpg" alt="这里写图片描述" style="zoom: 80%;" />

  <center>M=3的3阶B树</center>

**2 B+树**

应文件系统所需，是B树的变形，对于一棵M阶的B树：

- 叶子节点中**包含了所有的关键字信息**，**新增一个链指针**，以从小到大的顺序连接所有关键字

- 所有非叶子节点为索引，其**指针数=关键字个数**

- 位于关键字 K[i-1], K[i] 之间的指针 P[i]，指向关键字属于 **[** K[i-1], K[i]) 的子树

- B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据

  复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父

  结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

  <img src="https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/20160805192039968.jpg" alt="img" style="zoom: 80%;" />

**3 B*树**

是B+树的变形，非根非叶子节点，再增加**指向兄弟的指针**

- 非叶子节点**关键字个数至少 2/3M**，即块的最低使用率为2/3

- B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分

  数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字

  （因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之

  间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；

<img src="https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/524341-20160414101039660-287121250.jpg" alt="img" style="zoom:80%;" />

---

#### 红黑树

是一种**自平衡二叉查找树**，插入删除的时间/空间复杂度：O(logn)

具有以下特点：

1. 节点都是红色或者黑色
2. 根节点是黑色
3. 叶子节点都是黑色（NIL）
4. 每个红色节点的子节点都是黑色（从每个叶子节点到根的路径上，不能有2个连续的红色节点）
5. 从根节点到每个叶子节点的路径，都包含相同数目的黑色节点数

**优点**：解决二叉查找树会退化成线性结构的缺点

**应用场景**：JDK1.8后的hashmap和concurrentHashMap底层实现，TreeMap

---

#### 红黑树的变换

[图解红黑树](https://www.cnblogs.com/ahuntsun-blog/p/12458115.html)

插入一个新节点时，有可能树不再平衡，可以通过三种方式的变换使树保持平衡：

- **变色**；
- **左旋转**；
- **右旋转**；

**1. 变色**

为了重新符合红黑树的规则，需要把**红色**节点变为**黑色**，或者把**黑色**节点变为**红色**；

插入的**新节点**通常都是**红色节点**：

- 当插入的节点为**红色**的时候，大多数情况**不违反**红黑树的任何规则；
- 而**插入黑色节点，**必然会导致一条路径上多了一个**黑色节点**，这是很难调整的；
- 红色节点虽然可能导致**红红相连**的情况，但是这种情况可以通过**颜色调换和旋转**来调整；

**2. 左旋**

![image-20200303132706061](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/2.png)

**3. 右旋**

![image-20200303132529476](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/4.png)

---

#### 平衡二叉树（AVL）和红黑树区别

**1. AVL树**

AVL树是**严格的平衡二叉树**，平衡条件必须满足——**所有节点的左右子树高度差的绝对值不超过1**。不管我们是执行插入还是删除操作，只要不满足平衡条件，就要通过旋转来保持平衡，而旋转是非常**耗时**的，因此**AVL树适合用于插入与删除次数比较少，但查找多的情况**。

**2. 红黑树**

通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比**其它路径长出两倍**，因此，红黑树是一种**弱平衡二叉树**。由于是弱平衡，在**相同的节点情况下，AVL树的高度低于红黑树）**，相对于要求严格的AVL树来说，它的旋转次数少，所以**对于搜索，插入，删除操作较多的情况下，我们就用红黑树**。

---

#### LSM树

LSM树并不像B+树、红黑树一样是一颗严格的树状数据结构，它其实是一种**存储结构**

LSM树的核心特点是利用**顺序写**来提高写性能，但因为分层(此处分层是指的分为内存和文件两部分)的设计会稍微降低读性能，但是通过牺牲小部分读性能换来高性能写，使得LSM树成为非常流行的存储结构。

**1. LSM树的核心思想**

![img](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/v2-37576525d52091fd713bb13556c92861_1440w.jpg)

如上图所示，LSM树有以下三个重要组成部分：

***1) MemTable***

MemTable是在**内存**中的数据结构，用于保存最近更新的数据，会按照Key有序地组织这些数据，LSM树对于具体如何组织有序地组织数据并没有明确的数据结构定义，例如Hbase使跳跃表来保证内存中key的有序。

因为数据暂时保存在内存中，内存并不是可靠存储，如果断电会丢失数据，因此通常会通过WAL(Write-ahead logging，预写式日志)的方式来保证数据的可靠性。

***2) Immutable MemTable***

当 MemTable达到一定大小后，会转化成Immutable MemTable。Immutable MemTable是将转MemTable变为SSTable的一种中间状态。写操作由新的MemTable处理，在转存过程中不阻塞数据更新操作。

***3) SSTable(Sorted String Table)***

**有序键值对**集合，是LSM树组在**磁盘**中的数据结构。为了加快SSTable的读取，可以通过建立key的索引以及布隆过滤器来加快key的查找。

![img](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/v2-9eeda5082f56b1df20fa555d36b0e0ae_1440w.png)

这里需要关注一个重点，LSM树(Log-Structured-Merge-Tree)正如它的名字一样，LSM树会将所有的数据插入、修改、删除等操作记录(注意是操作记录)保存在内存之中，当此类操作达到一定的数据量后，再批量地顺序写入到磁盘当中。这与B+树不同，B+树数据的更新会直接在原数据所在处修改对应的值，但是LSM数的数据更新是日志式的，当一条数据更新是直接append一条更新记录完成的。这样设计的目的就是为了顺序写，不断地将Immutable MemTable flush到持久化存储即可，而不用去修改之前的SSTable中的key，保证了顺序写。

因此当MemTable达到一定大小flush到持久化存储变成SSTable后，在不同的SSTable中，可能存在相同Key的记录，当然最新的那条记录才是准确的。这样设计的虽然大大提高了写性能，但同时也会带来一些问题：

> 1）冗余存储，对于某个key，实际上除了最新的那条记录外，其他的记录都是冗余无用的，但是仍然占用了存储空间。因此需要进行Compact操作(合并多个SSTable)来清除冗余的记录。
> 2）读取时需要从最新的倒着查询，直到找到某个key的记录。最坏情况需要查询完所有的SSTable，这里可以通过前面提到的索引/布隆过滤器来优化查找速度。

**2. LSM树的Compact策略**

从上面可以看出，Compact操作是十分关键的操作，否则SSTable数量会不断膨胀。在Compact策略上，主要介绍两种基本策略：size-tiered和leveled。

***1) size-tiered 策略***

![img](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/v2-bedb057fde7a4ce4d5be2ea34fe86f59_1440w.jpg)

size-tiered策略保证每层SSTable的大小相近，同时限制每一层SSTable的数量。如上图，每层限制SSTable为N，当每层SSTable达到N后，则触发Compact操作合并这些SSTable，并将合并后的结果写入到下一层成为一个更大的sstable。

由此可以看出，*当层数达到一定数量时，最底层的单个SSTable的大小会变得非常大*。并且*size-tiered策略会导致空间放大比较严重*。即使对于同一层的SSTable，每个key的记录是可能存在多份的，只有当该层的SSTable执行compact操作才会消除这些key的冗余记录。

***2) leveled策略***

![img](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/v2-5f8de2e435e979936693631617a60d16_1440w.jpg)每一层的总大小固定，从上到下逐渐变大

leveled策略也是采用分层的思想，每一层限制总文件的大小。

但是跟size-tiered策略不同的是，leveled会将每一层切分成多个大小相近的SSTable。这些SSTable是这一层是**全局有序**的，意味着一个key在每一层至多只有1条记录，不存在冗余记录。之所以可以保证全局有序，是因为合并策略和size-tiered不同，接下来会详细提到。

![img](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/v2-8274669affe5b9602aff45ddff29e628_1440w.jpg)

[LSM树详解](https://zhuanlan.zhihu.com/p/181498475)

---

#### B+树和LSM树的区别（待整理）

LSM树会将所有的数据插入、修改、删除等操作记录(注意是操作记录)保存在内存之中，当此类操作达到一定的数据量后，再批量地顺序写入到磁盘当中。这与B+树不同，B+树数据的更新会直接在原数据所在处修改对应的值，但是LSM数的数据更新是日志式的，当一条数据更新是直接append一条更新记录完成的。

---

#### 跳表

**跳表的思想**：用“空间换时间”，通过给链表建立索引，提高了查找的效率，从而使得链表能够实现二分查找。所以跳表可以理解为是**可以实现二分查找的有序链表**

跳表特点：

- 查找/插入/删除时间复杂度：O(logn)，空间复杂度：O(n)

- 每个元素插入时随机生成它的level；
- 如果一个元素出现在level(x)，那么它肯定出现在x以下的level中；
- 最底层包含所有的元素；
- 每个索引节点包含两个指针，一个向下，一个向右；

![image-20210228224918097](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/image-20210228224918097.png)

##### 为什么Redis选择使用跳表而不是红黑树来实现有序集合？

Redis 中的有序集合(zset) 支持的操作：

1. 插入一个元素
2. 删除一个元素
3. 查找一个元素
4. 有序输出所有元素
5. 按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）

其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。

[Skip List--跳表（全网最详细的跳表文章没有之一）](https://www.jianshu.com/p/9d8296562806)

---

### :watermelon:算法

#### 排序算法

https://www.cnblogs.com/onepixel/articles/7674659.html

![image-20210113201934583](https://typora-image-ariellauu.oss-cn-beijing.aliyuncs.com/uPic/image-20210113201934583.png)

##### 为什么快排不稳定

**排序算法的稳定性**：两个值相同的元素在排序前后，位置没有发生变化，则排序算法稳定

Eg: （6A，6B，6C，2，5）对这个进行排序，排序之前相同的数6A与6B，A在B的前面，经过排序之后会变成

​    （2，5，6C，6A， 6B），所以说快速排序是一个不稳定的排序

##### 手撕快排

采用分治法，通过一趟排序将数据分为两部分，比基准（pivot）值小的元素放在基准值的前面，比基准值大的元素放在基准后面； 递归子序列

```java
public class QuickSort {
    public int[] quickSort(int[] arr){
        return quickSort(arr,0,arr.length-1);
    }

    public int[] quickSort(int[] arr,int left,int right){
        if(left<right){
          	//获取基准值在第一次排序后的下标位置
            int partitionIdx=partition(arr,left,right);
          	//对基准值左右进行排序
            quickSort(arr,left,partitionIdx-1);
            quickSort(arr,partitionIdx+1,right);
        }
        return arr;
    }

    public int partition(int[] arr,int left,int right){
        Random rand=new Random();
        int pivot=left+rand.nextInt(right-left);
        swap(arr,pivot,right);
        pivot=left;
        for(int i=left;i<right;i++){
            if(arr[i]<=arr[right]){
                swap(arr,pivot++,i);
            }
        }
        swap(arr,pivot,right);
        return pivot;
    }

    public void swap(int[] arr,int i,int j){
        int tmp=arr[i];
        arr[i]=arr[j];
        arr[j]=tmp;
    }
}
```

---

#### 算法题

#### 海量数据问题

1. [如何从大量的 URL 中找出相同的 URL？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-common-urls.md)

   **分治策略**

   1）分而治之，进行哈希取余；

   2）对每个子文件进行 HashSet 统计。

   **前缀树**

   1）利用字符串的公共前缀来降低存储成本，提高查询效率。

2. [如何从大量数据中找出高频词？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-top-100-words.md)

   **分治策略**

   1）分而治之，进行哈希取余；

   2）使用 HashMap 统计频数；

   3）求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

3. [如何找出某一天访问百度网站最多的 IP？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-top-1-ip.md)

   **分治策略**

   1）遍历日志，取出访问百度的ip

   2）分而治之，进行哈希取余；

   3）使用 HashMap 统计频数；

   4）求解**最大**的 TopN 个，用**小顶堆**；求解**最小**的 TopN 个，用**大顶堆**。

4. [如何在大量的数据中找出不重复的整数？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-no-repeat-number.md)

   **分治策略**

   先将 海量数据划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。

   **位图**

   **判断数字是否存在/是否重复的问题**，位图法是一种非常高效的方法，当然前提是：内存要满足位图法所需要的存储空间。

5. [如何在大量的数据中判断一个数是否存在？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-a-number-if-exists.md)

   **分治法**

   依然可以用分治法解决，方法与前面类似

   **位图法**

   由于 unsigned int 数字的范围是 `[0, 1 << 32)`，我们用 `1<<32=4,294,967,296` 个 bit 来表示每个数字。初始位均为 0，那么总共需要内存：4,294,967,296b≈512M。

   我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。

6. 判断图片URL是否存在于给定数据中

   分治+布隆过滤器+hashset

7. [如何查询最热门的查询串？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-hotest-query-string.md)

   **分治法（在这里不是很好）**

   1）划分为多个小文件

   2）求出每个文件最热门的10个查询串

   3）小顶堆进行最后统计

   **HashMap**

   1）先判断hashmap内存是否能装下

   2）利用hashmap统计结果

   3）小顶堆进行最后统计

   **前缀树**

   1）利用前缀树存储字符串出现次数

   2）小顶堆进行最后统计

8. [如何统计不同电话号码的个数？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/count-different-phone-numbers.md)

   **位图法**

   8 位电话号码可以表示的号码个数为 10^8 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。

9. [如何从 5 亿个数中找出中位数？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-mid-value-in-500-millions.md)

   **双堆法（数据量不大）**

   参考leetcode295，一个大顶堆一个小顶堆

   **分治法**

   对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

   划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。

   对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。

10. [如何按照 query 的频度排序？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/sort-the-query-strings-by-counts.md)

    **HashMap**

    如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。

    **分治法**

    分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 `hash(query) % 10` 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。

    接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用**外排序**）

    **堆外排序**：[外排序-维基百科](https://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F)

11. [如何找出排名前 500 的数？](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-rank-top-500-numbers.md)

    

[advanced java 海量数据](https://github.com/doocs/advanced-java/blob/main/docs/big-data/find-common-urls.md)

[常见海量数据问题总结](https://blog.csdn.net/hitxueliang/article/details/52153476?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control ) （大体没问题，有些小bug）

1. N个数如何取到最小的K个数
2. 求一个数的平方根，精确到0.01
3. 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。